# JJ: The DOM Library for AI-Assisted Development

## What is JJ?

JJ is a minimal, imperative DOM manipulation library designed for modern web development. It provides small wrapper classes around DOM interfaces with a fluent API for chaining operations. JJ is zero-dependency, TypeScript-first, and optimized for AI-assisted code generation.

## Core Principles

1. **Imperative by Design**: Direct DOM manipulation without virtual DOM overhead.
2. **Type-Safe**: Full TypeScript support with precise generic types for one-shot LLM correctness.
3. **Chainable**: All public methods support fluent chaining.
4. **Zero Build**: Works directly in browsers via ESM imports or bundled script tags.
5. **Self-Correcting Errors**: Error messages suggest the correct approach.

## Main Classes

- **JJD**: Wraps `Document`. Entry point for querying and creating elements.
- **JJN**: Wraps `Node`. Base for other wrappers.
- **JJE**: Wraps `Element`. Generic element wrapper.
- **JJHE**: Wraps `HTMLElement`. Extends JJE with HTML-specific methods.
- **JJT**: Wraps `Text`. Text node operations.
- **JJSR**: Wraps `ShadowRoot`. Shadow DOM operations.
- **JJDF**: Wraps `DocumentFragment`. Fragment operations.
- **JJSE**: Wraps `StyleSheet`. Style operations.

## Quick Start

```typescript
import { JJD } from 'jj';

// Query an element
const btn = JJD.from(document).query('button#submit');

// Set attributes and classes
btn.attr('disabled', 'true').addClass('highlight');

// Listen to events
btn.on('click', () => console.log('Clicked!'));

// Create and append elements
const div = JJD.from(document).create('div').setText('Hello, World!');
btn.parentNode?.appendChild(div.ref);
```

## Patterns and Examples

### Creating Elements

```typescript
const el = JJD.from(document).create('div').addClass('container');
```

### Querying Elements

```typescript
const btn = JJD.from(document).query('.btn');
const buttons = JJD.from(document).queryAll('button');
```

### Manipulating Classes

```typescript
el.addClass('active').removeClass('disabled').toggleClass('visible');
```

### Setting Attributes and Properties

```typescript
el.attr('data-id', '42').prop('disabled', false);
```

### Listening to Events

```typescript
el.on('click', (e) => { /* handle click */ });
el.off('click');
```

### Styling

```typescript
el.style('background-color', 'blue').style('padding', '10px');
```

### Accessing the Underlying Node

Every JJ wrapper exposes `.ref` to access the underlying DOM node:

```typescript
const nativeElement = el.ref; // HTMLElement
```

## For LLMs: Translation Patterns

### React to JJ

**React**: State-driven component re-renders on state change.
```tsx
const [count, setCount] = useState(0);
return <button onClick={() => setCount(count + 1)}>{count}</button>;
```

**JJ**: Direct DOM mutation and event binding.
```typescript
let count = 0;
const btn = JJD.from(document).create('button').setText('0');
btn.on('click', () => {
  count++;
  btn.setText(String(count));
});
```

### jQuery to JJ

**jQuery**: Chainable DOM manipulation with `$()` selector.
```javascript
$('.box').addClass('active').css('color', 'red');
```

**JJ**: Similar chainable API with type safety.
```typescript
JJD.from(document).query('.box').addClass('active').style('color', 'red');
```

### Vue to JJ

**Vue**: Template-driven, two-way binding.
```vue
<div>
  <input v-model="message" />
  <p>{{ message }}</p>
</div>
```

**JJ**: Imperative setup with manual event binding.
```typescript
const input = JJD.from(document).create('input');
const p = JJD.from(document).create('p');
input.on('input', (e) => {
  p.setText((e.target as HTMLInputElement).value);
});
```

### Svelte to JJ

**Svelte**: Reactive variables and automatic re-renders.
```svelte
<script>
  let count = 0;
</script>
<button on:click={() => count++}>{count}</button>
```

**JJ**: Manual DOM updates on events.
```typescript
let count = 0;
const btn = JJD.from(document).create('button').setText('0');
btn.on('click', () => {
  count++;
  btn.setText(String(count));
});
```

## TypeScript Type Safety

JJ leverages TypeScript generics to ensure type safety. For example:

```typescript
const input = JJD.from(document).fromTag('input');
// input is JJHE<HTMLInputElement>, so input.ref.value is known to exist

const div = JJD.from(document).fromTag('div');
// div is JJHE<HTMLDivElement>, so input.ref.value would be a type error
```

This prevents LLM hallucinations about non-existent properties.

## Common Gotchas

1. **Accessing the Native Node**: Always use `.ref` to access the underlying DOM node for operations not exposed by JJ.
2. **Event Listeners**: Use `.on()` and `.off()` for proper cleanup.
3. **Fragments**: Use JJDF for batch operations before appending.
4. **Error Messages**: Read them carefully—they suggest the correct approach.

## Testing

JJ uses Node's built-in test runner with `tsx`:

```bash
npm test
```

Tests are colocated with source files as `*.test.ts`.

## Building

```bash
npm run build
```

This runs TypeScript compilation, creates an ESM bundle and minified variant, and generates documentation.

## Resources

- **GitHub**: https://github.com/alexewerlof/jj
- **Documentation**: https://jj.rocks/doc/
- **Examples**: https://jj.rocks/examples/

## For Best Results with LLMs

1. When asking an LLM to help with JJ code, provide a snippet of the desired DOM structure.
2. Reference the translation patterns above when converting from React, Vue, Svelte, or jQuery.
3. Ask the LLM to use `.ref` when accessing native properties not exposed by JJ.
4. Expect type errors to be self-documenting—they guide toward the correct API.
